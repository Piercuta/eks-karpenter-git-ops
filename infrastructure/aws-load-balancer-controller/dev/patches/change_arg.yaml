# patches/patch-alb-controller-args.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: aws-load-balancer-controller
  namespace: kube-system
spec:
  template:
    spec:
      containers:
      - name: aws-load-balancer-controller
        args:
        - '--cluster-name={{ .Values.cluster_name }}'
        - '--ingress-class=alb'
        - '--aws-vpc-id={{ .Values.vpc_id }}'




  Parfait ! üëå
On va faire l‚Äô**option B** :

> ‚öôÔ∏è Utiliser  pour r√©cup√©rer une valeur dans  ‚Üí la mettre dans un `ConfigMap` dans le cluster ‚Üí et l‚Äôinjecter dans ton chart  via ton `kustomization.yaml`.

Ainsi :

* üíæ Ton `port` n‚Äôest jamais dans Git
* üì¶  garde le contr√¥le GitOps
* ‚ö° La valeur est dynamique et g√©r√©e par AWS

---

## üÖê √âtape 1 ‚Äî ExternalSecret ‚Üí Secret Kubernetes

**`external-secret.yaml`**

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: my-app-port
  namespace: my-namespace
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-parameter-store
    kind: ClusterSecretStore
  target:
    name: my-app-port
  data:
    - secretKey: PORT
      remoteRef:
        key: /my/app/port
```

‚û°Ô∏è ESO cr√©e automatiquement un `Secret` nomm√© `my-app-port` avec une cl√© `PORT`.

---

## üÖë √âtape 2 ‚Äî Convertir ce Secret en ConfigMap (pour Helm)

> ‚ö†Ô∏è Beaucoup de charts Helm lisent plus facilement un `ConfigMap` qu‚Äôun `Secret`.

Cr√©e un petit `ConfigMapGenerator` avec une substitution Kustomize :

**`configmap-from-secret.yaml`**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-app-config
  namespace: my-namespace
data:
  PORT: ${PORT}
```

**`kustomization.yaml`**

```yaml
resources:
  - configmap-from-secret.yaml
  - external-secret.yaml

vars:
  - name: PORT
    objref:
      kind: Secret
      name: my-app-port
      apiVersion: v1
    fieldref:
      fieldpath: data.PORT

helmCharts:
  - name: my-app
    repo: https://charts.bitnami.com/bitnami
    version: 15.2.0
    releaseName: my-app
    namespace: my-namespace
    valuesInline:
      service:
        port: ${PORT}
```

---

## ‚öôÔ∏è Fonctionnement

1. L‚Äô`ExternalSecret` r√©cup√®re `/my/app/port` dans Parameter Store et cr√©e `Secret my-app-port`
2. `kustomize vars` lit `data.PORT` dans ce `Secret`
3. Substitution `${PORT}` ‚Üí inject√©e dans `valuesInline.service.port`
4. ArgoCD applique le chart Helm avec la bonne valeur

---

## ‚úÖ Avantages

* Aucun commit d‚ÄôID/port dans Git
* Valeur maintenue c√¥t√© AWS Parameter Store
* ArgoCD garde un flux GitOps propre et pr√©visible

---

Si tu veux, je peux te faire une **arborescence de dossier GitOps propre (`/infra` et `/app`)** avec tout d√©j√† branch√©.
Veux-tu que je te la pr√©pare ?
